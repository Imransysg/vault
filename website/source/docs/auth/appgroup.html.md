---
layout: "docs"
page_title: "Auth Backend: AppGroup"
sidebar_current: "docs-auth-appgroup"
description: |-
  The AppGroup backend allows any App(s), or Group(s) of Apps to authenticate with Vault.
---

# Auth Backend: AppGroup

Any registered App(s) or Group(s) of Apps can authenticate themselves
with Vault using UserIDs that are specifically generated to serve that
purpose. The UserIDs have nice properties like usage-limit and expiration,
that can address numerous use-cases. An App can represent a service, or
a machine or anything that can be IDed. Since an App can be a machine in
itself, the AppGroup backend is a potential successor for the App-ID backend.

### What Does An App Mean?
An App represents a set of Vault policies, under a name. In essense,
if a machine needs to authenticate with Vault with a set of policies,
an App can be registered under the machine's name with the desired set
of policies. If a service requires a set of Vault policies, an App can
be registered under the service's name with the desired policies.

### What Does A Group Mean?
A Group represents a set of Apps and hence a bigger set of Vault policies.
Basically, Apps registered with the backend are logically grouped under a
name. The advantage of this logical grouping of Apps is that, the properties
of UserIDs that are generated directly on the Group, or the tokens fetched
using the UserIDs generated on a Group to access a set Apps, can be operated
at a Group level itself. The options (documented below) set on a Group
supercedes the options on the individual participating Apps.

TrustedService:

### Selectors and UserIDs
UserID is a credential to be used by the Apps to authenticate themselves
with Vault and inturn receive a Vault token. Along with UserID the Apps
also need to provide the Selector, which represents they way the UserID
was created.

Selector informs the backend about the kind of login being performed. By
design, a UserID can be generated in three different ways: on an App, on
a Group or on a combination of both (`generic`). These three ways translates
to three types of selector credentials. When a UserID generated against an
App is used to perform login, then its selector should be `app/<app_name>`.
If a UserID generated against a Group is used to perform login, then its
selector should be `group/<group_name>`. If the UserID is generated in a
`generic` mode then the selector should just be `generic`.


UserIDs by default will expire after the backend mount's maximum TTL duration,
since the UserID creation. The duration after which the UserID is expired can
be further restricted using the `userid_ttl` option on all types of UserID
creation. Number of times a generated UserID can by utilized to fetch a Vault
token can be configured using `num_uses` option on all types of UserID creation.
UserIDs can be chosen to be retrieved in a secure manner using `wrapped` option
(explained later).


### Wrapped UserIDs (Cubbyhole Mode).

Vault by default will have cubbyhole backend mounted at 'cubbyhole/'.
This backend provides a personalized storage space for all the Vault
tokens. There are a few workflows around the cubbyhole, which can solve
a specific set of problems. The principles of cubbyhole usage are outlined
[here] (https://www.hashicorp.com/blog/vault-cubbyhole-principles.html).

A `wrapped` option can be set while registering an App, while registering
a Group, or while generating a UserID in the `generic` mode. When this
option is set, the cubbyhole mode of UserID retrieval will be activated.
In this mode, the plaintext UserID will not be returned directly.
Instead a new token will be created with a lifetime matching the value
of the respective 'wrapped' option. The actual response object containing
the UserID will be stored in the cubbyhole of this new token and the token
is returned as a response. The interesting part here is that the cubbyhole
of this token can be read only once, after which the token along with its
cubbyhole is destroyed. So, if a service which is supposed to receive this
UserID, fails to read the UserID from the token's cubbyhole, a security alert
can be promptly triggered. Auditing around cubbyhole read, will make the
security breach detectable.

### Creds Specific Endpoints

The UserIDs generated by the backend are randon 128 bit UUIDs that has
good cryptographic properties. Usage of 'app/<app_name>/creds',
'group/<group_name>/creds' and 'generic/creds' endpoints are encouraged
to be used over their corresponding 'creds-specific' counterparts. This
is both to obviate the need for clients to bother about generating UserIDs
and assigning them, and to avoid weak UserIDs. In case the clients are
assigning the UserIDs based on the properties of hardware, or using any
methods that can make the UserIDs discoverable, it can lead to unnecessary
security vulnerabilities.

The 'creds-specific' endpoints are provided keeping in mind the use-cases
where there will be a specific need to assign the UserIDs rather than use
the ones that are generated in the backend. For example, if the hardware,
can truely and safely identify themselves with a unique ID, then that ID
can be assigned to be used to access a set of Apps. But, these use-cases
fall into the category of "you know what you are doing" scenarios. Use
with caution.

### Apps/Groups/UserIDs/Tokens Are All Just Policies

Say, an App has a set of policies, a UserID is generated against it and
login is performed with that UserID along with the App's selector. The
resulting token will have access to a set of policies. If the subsets
of this set of policies, identifies a multitude of other Apps, by all
means, the token is capable of accessing all those Apps. In this case,
the UserID was scoped to be used along with the specific App to generate
the token. This does not mean that the token generated can access only
a specific App. The point is that an App or a Group of Apps, represent
a set of policies, nothing more.

